= DSL2: simpler syntax, modules and beyond

== Basic concepts

DSL2 is our new syntax to improve readability and allow the use of modules, as well as a few extra improvements. 

Despite this and to allow backward compatibility to exisiting pipelines, DSL1 is still a valid way of writing pipelines and therefore the dsl2 update has to be defined the following directive at the beginning of your workflow script: 

[source,nextflow,linenums]
----
nextflow.enable.dsl=2
----

DSL2 core features are:

* Improved readability of pipelines 
* Splitting of processes into modules and submodules that are portable between pipelines/workflows
* 

=== Functions
Nextflow allows the definition of custom function in the workflow script using the following syntax:

[source,nextflow,linenums]
----
def <function name> ( arg1, arg, .. ) {
    <function body>
}
----
For example:

[source,nextflow,linenums]
----
def foo() {
    'Hello world'
}

def bar(alpha, omega) {
    alpha + omega
}
----
The above snippet defines two simple functions, that can be invoked in the workflow script as `foo()` which returns the `Hello world` string and `bar(10,20)` which return the sum of two parameters.

TIP: Functions implicitly return the result of the last evaluated statement.

The keyword `return` can be used to explicitly exit from a function returning the specified value. for example:

[source,nextflow,linenums]
----
def fib( x ) {
    if( x <= 1 )
        return x
    else
        fib(x-1) + fib(x-2)
}
----

=== Process

== Process definition

The new DSL separates the definition of a process from its invocation. The process definition follows the usual syntax as described in the process documentation. The only difference is that the `from` and `into` channel declaration has to be omitted.

Then a process can be invoked as a function in the `workflow` scope, passing the expected input channels as parameters as it if were a custom function. For example (updated from earlier to dsl2):

[source,nextflow,linenums]
----
nextflow.enable.dsl=2

process splitLetters {

    input:
    val x

    output:
    file 'chunk_*'

    """
    printf '$x' | split -b 6 - chunk_
    """
}

process convertToUpper {

    input:
    file y

    output:
    stdout

    """
    cat $y | tr '[a-z]' '[A-Z]'
    """
}

params.greeting  = 'Hello world!'
greeting_ch = Channel.from(params.greeting)

workflow {

    letters_ch = splitLetters(greeting_ch)
    uppercase_ch = convertToUpper( letters_ch.flatten() )
    uppercase_ch.view{ it.trim() }

}
----

Warning:A process component can be invoked only once in the same workflow context.

== Process composition
Processes having matching input-output declaration can be composed so that the output of the first process is passed as input to the following process. Taking in consideration the previous process definition, itâ€™s possible to write the following:

[source,nextflow,linenums]
----
workflow {
    bar(foo())
}
----

== Process outputs
A process output can also be accessed using the `out` attribute for the respective process object. For example:

[source,nextflow,linenums]
----
workflow {
    foo()
    bar(foo.out)
    bar.out.view()
}
----

When a process defines two or more output channels, each of them can be accessed using the array element operator e.g. `out[0]`, `out[1]`, etc. or using named outputs (see below).

== Process named output
The process output definition allows the use of the `emit` option to define a name identifier that can be used to reference the channel in the external scope. For example:

[source,nextflow,linenums]
----
process foo {
  output:
    path '*.bam', emit: samples_bam

  '''
  your_command --here
  '''
}

workflow {
    foo()
    foo.out.samples_bam.view()
}
----

== Process named stdout
The process can name stdout using the `emit` option:

[source,nextflow,linenums]
----
process sayHello {
    input:
        val cheers
    output:
        stdout emit: verbiage
    script:
    """
    echo -n $cheers
    """
}

workflow {
    things = channel.of('Hello world!', 'Yo, dude!', 'Duck!')
    sayHello(things)
    sayHello.out.verbiage.view()
}
----

=== Workflow

== Workflow definition
The `workflow` keyword allows the definition of sub-workflow components that enclose the invocation of one or more processes and operators:

[source,nextflow,linenums]
----
workflow my_pipeline {
    foo()
    bar( foo.out.collect() )
}
----

For example, the above snippet defines a workflow component, named `my_pipeline`, that can be invoked from another workflow component definition as any other function or process i.e. `my_pipeline()`.

